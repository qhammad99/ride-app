---
<<<<<<< HEAD
description: How to create basic API Steps in Motia
=======
description: What are Motia API Steps and a Typescript example
globs: 
alwaysApply: false
---
# API Steps Guide

API Steps expose HTTP endpoints that can trigger workflows and emit events.

## Basic API Step Pattern
```typescript
// Import necessary types and libraries
import { ApiRouteConfig, Handlers } from 'motia'; // Core Motia types for API steps
import { z } from 'zod'; // Zod library for data validation

// Define the configuration for the API Step
export const config: ApiRouteConfig = {
  // 'type' specifies the step as an API endpoint.
  type: 'api',
  // 'name' is a unique identifier for this API step, used internally and for linking handlers.
  name: 'CreateResource',
  // 'path' defines the URL path for this endpoint (e.g., http://localhost:3000/resources).
  path: '/resources',
  // 'method' specifies the HTTP method (e.g., GET, POST, PUT, DELETE).
  method: 'POST',
  // 'emits' is an array of topic strings that this step will publish messages to upon successful execution.
  emits: ['resource.created'],
  // 'flows' associates this step with one or more defined workflows.
  flows: ['resource-management'],
  // 'bodySchema' defines the expected structure and validation rules for the request body using Zod.
  // This ensures that incoming data matches the expected format before the handler is invoked.
  bodySchema: z.object({
    title: z.string().min(1, "Title cannot be empty"), // Expect a 'title' property of type string, non-empty.
    description: z.string().optional(), // Optional description field
    category: z.string().min(1, "Category is required"), // Expect a category
    metadata: z.record(z.any()).optional() // Optional metadata object
  })
};

// Define the handler function that contains the logic for this API endpoint.
// Handlers['CreateResource'] links this handler to the 'CreateResource' configuration.
// 'req' (request) contains information about the incoming HTTP request (body, params, query, headers).
// The second argument is the context object, providing access to 'emit' (for sending messages) and 'logger'.
export const handler: Handlers['CreateResource'] = async (req, { emit, logger }) => {
  // Destructure the validated request body. Zod validation happens before the handler is called.
  // If validation fails, Motia automatically sends a 400 Bad Request response.
  const { title, description, category, metadata } = req.body;
  
  // Use the logger for structured logging. It's good practice to log key events or data.
  logger.info('Attempting to create resource', { title, category });
  
  // Business logic for creating a resource would go here (e.g., database interaction).
  // For this example, we'll simulate resource creation.
  const resourceId = crypto.randomUUID(); // Generate a new resource ID

  // Create the resource data structure
  const resourceData = {
    id: resourceId,
    title,
    description,
    category,
    metadata,
    status: 'active',
    createdAt: new Date().toISOString()
  };

  // Emit an event to a topic. This can trigger other steps in the workflow.
  await emit({
    // 'topic' must be one of the topics listed in config.emits.
    topic: 'resource.created',
    // 'data' is the payload of the event message.
    data: resourceData
  });
  
  logger.info('Resource created successfully', { resourceId, title, category });

  // Return a response object for the HTTP request.
  return {
    // 'status' is the HTTP status code. 201 Created is appropriate for a successful POST request.
    status: 201,
    // 'body' is the JSON response body sent back to the client.
    body: { 
      message: 'Resource created successfully', 
      resource: {
        id: resourceId,
        title,
        category,
        status: 'active'
      }
    }
  };
};
```

## Common API Patterns

### GET Endpoint
```typescript
// Configuration for a GET API endpoint to fetch resources.
export const configGetResources: ApiRouteConfig = {
  type: 'api',
  name: 'GetResources',
  path: '/resources', // Standard path for retrieving a collection of resources.
  method: 'GET',  // HTTP GET method for data retrieval.
  emits: ['resources.fetched'], // Topic to emit to after fetching resources.
  flows: ['resource-management'] // Associates with the resource management flow.
  // No bodySchema needed for GET requests typically, but queryParamsSchema can be used for query parameters.
};

// Handler for the GET /resources endpoint.
export const handlerGetResources: Handlers['GetResources'] = async (req, { emit, logger }) => {
  // In a real application, you would fetch resources from a database or another service.
  // req.queryParams can be used to access query string parameters (e.g., /resources?limit=10&category=active).
  const { limit = 10, category, status = 'active' } = req.queryParams;
  
  logger.info('Fetching resources', { limit, category, status });
  
  // Example data - in reality this would come from your data store
  const resources = [
    { 
      id: '1', 
      title: 'Sample Resource 1', 
      category: 'documents', 
      status: 'active',
      createdAt: '2024-01-01T00:00:00Z'
    },
    { 
      id: '2', 
      title: 'Sample Resource 2', 
      category: 'media', 
      status: 'active',
      createdAt: '2024-01-02T00:00:00Z'
    }
  ];

  // Apply filtering based on query parameters
  const filteredResources = resources.filter(resource => {
    if (category && resource.category !== category) return false;
    if (status && resource.status !== status) return false;
    return true;
  }).slice(0, parseInt(limit));

  // Emit an event with the fetched resources.
  await emit({
    topic: 'resources.fetched',
    data: { resources: filteredResources, count: filteredResources.length, filters: { category, status } }
  });
  
  // Return the resources in the response body with a 200 OK status.
  return {
    status: 200,
    body: { 
      resources: filteredResources,
      total: filteredResources.length,
      filters: { category, status, limit }
    }
  };
};
```

### API with Path Parameters
```typescript
// Configuration for a GET API endpoint that uses a path parameter to fetch a specific resource.
export const configGetResourceById: ApiRouteConfig = {
  type: 'api',
  name: 'GetResourceById',
  path: '/resources/:id', // ':id' defines a path parameter named 'id'.
  method: 'GET',
  emits: ['resource.retrieved'], // Topic for when a single resource is retrieved.
  flows: ['resource-management']
  // pathParamsSchema can be defined here using Zod if specific validation for path params is needed,
  // e.g., pathParamsSchema: z.object({ id: z.string().uuid("Resource ID must be a UUID") })
};

// Handler for the GET /resources/:id endpoint.
export const handlerGetResourceById: Handlers['GetResourceById'] = async (req, { emit, logger }) => {
  // Access path parameters from req.pathParams.
  // If pathParamsSchema was defined, 'id' here would be validated accordingly.
  const resourceId = req.pathParams.id;
  
  logger.info('Fetching resource by ID', { resourceId });

  // Simulate fetching a resource. If resourceId is 'notfound', simulate resource not found.
  // In a real application, this would involve a database lookup.
  let resource: { id: string; title: string; category: string; status: string; createdAt: string } | undefined;
  if (resourceId === 'notfound') {
    resource = undefined; // Simulate resource not found
  } else {
    // Simulate finding the resource
    resource = { 
      id: resourceId, 
      title: 'Sample Resource', 
      category: 'documents',
      status: 'active',
      createdAt: '2024-01-01T00:00:00Z'
    }; 
  }

  if (!resource) { 
    logger.warn('Resource not found with ID', { resourceId });
    return {
      status: 404,
      body: { 
        message: 'Resource not found',
        resourceId 
      }
    };
  }
  
  // Emit an event (optional, but can be useful for auditing or further processing).
  await emit({
    topic: 'resource.retrieved',
    data: { resource }
  });

  logger.info('Resource retrieved successfully', { resourceId, title: resource.title });

  // Return the found resource with a 200 OK status.
  return {
    status: 200,
    body: { 
      resource,
      retrievedAt: new Date().toISOString()
    }
  };
};
``` 