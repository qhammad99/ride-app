---
description: Comprehensive workflow patterns for building complex business processes with Motia
globs: 
alwaysApply: false
---
# Workflow Patterns

Build sophisticated business workflows using proven patterns for complex processes, state machines, and multi-step operations.

## Linear Workflow Pattern

### Sequential Processing Chain

```typescript
// steps/workflows/order-processing/01-validate-order.step.ts
import { EventConfig, Handlers } from 'motia'
import { z } from 'zod'

export const config: EventConfig = {
  type: 'event',
  name: 'ValidateOrder',
  description: 'First step: validate order data and inventory',
  subscribes: ['order.submitted'],
  emits: ['order.validated', 'order.validation.failed'],
  input: z.object({
    orderId: z.string(),
    customerId: z.string(),
    items: z.array(z.object({
      productId: z.string(),
      quantity: z.number(),
      price: z.number()
    })),
    shippingAddress: z.record(z.string()),
    paymentMethod: z.string(),
    metadata: z.record(z.any()).optional()
  }),
  flows: ['order-processing']
}

export const handler: Handlers['ValidateOrder'] = async (input, { emit, logger, state }) => {
  const { orderId, customerId, items, shippingAddress, paymentMethod } = input
  
  try {
    // Initialize workflow state
    await state.set('workflows', `order:${orderId}`, {
      orderId,
      status: 'validating',
      currentStep: 'validate',
      startedAt: new Date().toISOString(),
      steps: {
        validate: { status: 'in_progress', startedAt: new Date().toISOString() }
      }
    })
    
    // Validation logic
    const validationResults = await validateOrderData(input, state)
    
    if (validationResults.valid) {
      // Update workflow state
      await state.set('workflows', `order:${orderId}`, {
        orderId,
        status: 'validated',
        currentStep: 'process_payment',
        steps: {
          validate: { status: 'completed', completedAt: new Date().toISOString() }
        }
      })
      
      await emit({
        topic: 'order.validated',
        data: {
          orderId,
          customerId,
          validatedItems: validationResults.items,
          total: validationResults.total,
          shippingAddress,
          paymentMethod
        }
      })
      
      logger.info('Order validated successfully', { orderId })
    } else {
      await emit({
        topic: 'order.validation.failed',
        data: {
          orderId,
          customerId,
          errors: validationResults.errors,
          reason: 'validation_failed'
        }
      })
      
      logger.warn('Order validation failed', { orderId, errors: validationResults.errors })
    }
    
  } catch (error) {
    logger.error('Order validation error', { error: error.message, orderId })
    
    await emit({
      topic: 'order.validation.failed',
      data: { orderId, customerId, reason: 'system_error', error: error.message }
    })
  }
}

async function validateOrderData(input: any, state: any) {
  const errors = []
  const validatedItems = []
  let total = 0
  
  // Validate customer
  const customer = await state.get('customers', input.customerId)
  if (!customer) {
    errors.push('Customer not found')
  }
  
  // Validate items and inventory
  for (const item of input.items) {
    const product = await state.get('products', item.productId)
    if (!product) {
      errors.push(`Product ${item.productId} not found`)
      continue
    }
    
    const inventory = await state.get('inventory', item.productId)
    if (!inventory || inventory.quantity < item.quantity) {
      errors.push(`Insufficient inventory for product ${item.productId}`)
      continue
    }
    
    validatedItems.push({
      ...item,
      productName: product.name,
      unitPrice: product.price
    })
    total += product.price * item.quantity
  }
  
  return {
    valid: errors.length === 0,
    errors,
    items: validatedItems,
    total
  }
}
```

```typescript
// steps/workflows/order-processing/02-process-payment.step.ts
import { EventConfig, Handlers } from 'motia'
import { z } from 'zod'

export const config: EventConfig = {
  type: 'event',
  name: 'ProcessPayment',
  description: 'Second step: process payment for validated order',
  subscribes: ['order.validated'],
  emits: ['payment.processed', 'payment.failed', 'order.cancelled'],
  input: z.object({
    orderId: z.string(),
    customerId: z.string(),
    total: z.number(),
    paymentMethod: z.string(),
    validatedItems: z.array(z.record(z.any()))
  }),
  flows: ['order-processing']
}

export const handler: Handlers['ProcessPayment'] = async (input, { emit, logger, state }) => {
  const { orderId, customerId, total, paymentMethod } = input
  
  try {
    // Update workflow state
    await updateWorkflowStep(orderId, 'process_payment', 'in_progress', state)
    
    // Process payment
    const paymentResult = await processPayment({
      customerId,
      amount: total,
      method: paymentMethod,
      orderId
    })
    
    if (paymentResult.success) {
      await updateWorkflowStep(orderId, 'process_payment', 'completed', state)
      
      await emit({
        topic: 'payment.processed',
        data: {
          orderId,
          customerId,
          paymentId: paymentResult.paymentId,
          amount: total,
          items: input.validatedItems
        }
      })
      
      logger.info('Payment processed successfully', { orderId, paymentId: paymentResult.paymentId })
    } else {
      await updateWorkflowStep(orderId, 'process_payment', 'failed', state)
      
      if (paymentResult.retryable) {
        await emit({
          topic: 'payment.failed',
          data: { orderId, customerId, reason: paymentResult.reason, retryable: true }
        })
      } else {
        await emit({
          topic: 'order.cancelled',
          data: { orderId, customerId, reason: 'payment_failed' }
        })
      }
    }
    
  } catch (error) {
    logger.error('Payment processing error', { error: error.message, orderId })
    await emit({
      topic: 'payment.failed',
      data: { orderId, customerId, reason: 'system_error', retryable: true }
    })
  }
}

async function updateWorkflowStep(orderId: string, stepName: string, status: string, state: any) {
  const workflow = await state.get('workflows', `order:${orderId}`)
  if (workflow) {
    workflow.steps[stepName] = {
      status,
      [status === 'completed' ? 'completedAt' : status === 'in_progress' ? 'startedAt' : 'failedAt']: new Date().toISOString()
    }
    await state.set('workflows', `order:${orderId}`, workflow)
  }
}

async function processPayment(paymentData: any) {
  // Payment processing logic
  return {
    success: true,
    paymentId: crypto.randomUUID(),
    transactionId: `txn_${Date.now()}`
  }
}
```

## Parallel Workflow Pattern

### Fan-out/Fan-in Processing

```typescript
// steps/workflows/content-processing/content-dispatcher.step.ts
import { EventConfig, Handlers } from 'motia'
import { z } from 'zod'

export const config: EventConfig = {
  type: 'event',
  name: 'ContentDispatcher',
  description: 'Dispatch content for parallel processing',
  subscribes: ['content.uploaded'],
  emits: ['content.text.extract', 'content.image.process', 'content.metadata.extract'],
  input: z.object({
    contentId: z.string(),
    contentType: z.string(),
    filePath: z.string(),
    userId: z.string(),
    processingOptions: z.record(z.any()).optional()
  }),
  flows: ['content-processing']
}

export const handler: Handlers['ContentDispatcher'] = async (input, { emit, logger, state }) => {
  const { contentId, contentType, filePath, userId, processingOptions } = input
  
  try {
    // Initialize parallel workflow
    const workflowId = `content:${contentId}`
    const parallelTasks = []
    
    // Determine which parallel tasks to run based on content type
    if (contentType.includes('text') || contentType === 'application/pdf') {
      parallelTasks.push('text_extraction')
    }
    
    if (contentType.startsWith('image/')) {
      parallelTasks.push('image_processing')
    }
    
    // Metadata extraction always runs
    parallelTasks.push('metadata_extraction')
    
    // Store workflow state for coordination
    await state.set('workflows', workflowId, {
      contentId,
      userId,
      status: 'parallel_processing',
      totalTasks: parallelTasks.length,
      completedTasks: 0,
      tasks: parallelTasks.reduce((acc, task) => {
        acc[task] = { status: 'pending', startedAt: new Date().toISOString() }
        return acc
      }, {}),
      results: {},
      startedAt: new Date().toISOString()
    })
    
    // Emit parallel tasks
    if (parallelTasks.includes('text_extraction')) {
      await emit({
        topic: 'content.text.extract',
        data: { workflowId, contentId, filePath, userId, options: processingOptions }
      })
    }
    
    if (parallelTasks.includes('image_processing')) {
      await emit({
        topic: 'content.image.process',
        data: { workflowId, contentId, filePath, userId, options: processingOptions }
      })
    }
    
    if (parallelTasks.includes('metadata_extraction')) {
      await emit({
        topic: 'content.metadata.extract',
        data: { workflowId, contentId, filePath, userId, options: processingOptions }
      })
    }
    
    logger.info('Content processing dispatched', { 
      contentId, 
      parallelTasks: parallelTasks.length 
    })
    
  } catch (error) {
    logger.error('Content dispatch failed', { error: error.message, contentId })
  }
}
```

```typescript
// steps/workflows/content-processing/content-aggregator.step.ts
import { EventConfig, Handlers } from 'motia'
import { z } from 'zod'

export const config: EventConfig = {
  type: 'event',
  name: 'ContentAggregator',
  description: 'Aggregate results from parallel content processing tasks',
  subscribes: ['task.completed'],
  emits: ['content.processing.completed', 'content.processing.failed'],
  input: z.object({
    workflowId: z.string(),
    taskType: z.string(),
    result: z.record(z.any()),
    success: z.boolean(),
    error: z.string().optional()
  }),
  flows: ['content-processing']
}

export const handler: Handlers['ContentAggregator'] = async (input, { emit, logger, state }) => {
  const { workflowId, taskType, result, success, error } = input
  
  try {
    // Get current workflow state
    const workflow = await state.get('workflows', workflowId)
    if (!workflow) {
      logger.warn('Workflow not found', { workflowId })
      return
    }
    
    // Update task status and results
    if (success) {
      workflow.tasks[taskType].status = 'completed'
      workflow.tasks[taskType].completedAt = new Date().toISOString()
      workflow.results[taskType] = result
      workflow.completedTasks += 1
    } else {
      workflow.tasks[taskType].status = 'failed'
      workflow.tasks[taskType].failedAt = new Date().toISOString()
      workflow.tasks[taskType].error = error
      workflow.completedTasks += 1
    }
    
    // Save updated workflow state
    await state.set('workflows', workflowId, workflow)
    
    // Check if all tasks are complete
    if (workflow.completedTasks === workflow.totalTasks) {
      const allTasksSuccessful = Object.values(workflow.tasks).every(
        (task: any) => task.status === 'completed'
      )
      
      if (allTasksSuccessful) {
        // All tasks completed successfully
        workflow.status = 'completed'
        workflow.completedAt = new Date().toISOString()
        
        await state.set('workflows', workflowId, workflow)
        
        await emit({
          topic: 'content.processing.completed',
          data: {
            contentId: workflow.contentId,
            userId: workflow.userId,
            results: workflow.results,
            processingTime: new Date().getTime() - new Date(workflow.startedAt).getTime()
          }
        })
        
        logger.info('Content processing completed', { 
          contentId: workflow.contentId,
          tasks: workflow.totalTasks 
        })
      } else {
        // Some tasks failed
        workflow.status = 'partially_failed'
        workflow.completedAt = new Date().toISOString()
        
        await state.set('workflows', workflowId, workflow)
        
        const failedTasks = Object.entries(workflow.tasks)
          .filter(([_, task]: [string, any]) => task.status === 'failed')
          .map(([taskType, task]) => ({ taskType, error: task.error }))
        
        await emit({
          topic: 'content.processing.failed',
          data: {
            contentId: workflow.contentId,
            userId: workflow.userId,
            failedTasks,
            partialResults: workflow.results
          }
        })
        
        logger.warn('Content processing partially failed', { 
          contentId: workflow.contentId,
          failedTasks: failedTasks.length 
        })
      }
    }
    
  } catch (error) {
    logger.error('Content aggregation failed', { error: error.message, workflowId })
  }
}
```

## State Machine Workflow Pattern

### Document Approval Workflow

```typescript
// steps/workflows/document-approval/state-machine.step.ts
import { EventConfig, Handlers } from 'motia'
import { z } from 'zod'

type DocumentState = 'draft' | 'submitted' | 'under_review' | 'approved' | 'rejected' | 'published'
type DocumentAction = 'submit' | 'approve' | 'reject' | 'publish' | 'edit' | 'withdraw'

export const config: EventConfig = {
  type: 'event',
  name: 'DocumentStateMachine',
  description: 'Handle document state transitions in approval workflow',
  subscribes: ['document.action'],
  emits: ['document.state.changed', 'notification.send', 'workflow.completed'],
  input: z.object({
    documentId: z.string(),
    action: z.enum(['submit', 'approve', 'reject', 'publish', 'edit', 'withdraw']),
    userId: z.string(),
    comment: z.string().optional(),
    metadata: z.record(z.any()).optional()
  }),
  flows: ['document-approval']
}

export const handler: Handlers['DocumentStateMachine'] = async (input, { emit, logger, state }) => {
  const { documentId, action, userId, comment, metadata } = input
  
  try {
    // Get current document state
    const document = await state.get('documents', documentId)
    if (!document) {
      throw new Error('Document not found')
    }
    
    const currentState = document.state as DocumentState
    
    // Validate transition
    const transition = validateTransition(currentState, action as DocumentAction, userId, document)
    
    if (!transition.valid) {
      logger.warn('Invalid state transition', { 
        documentId, 
        currentState, 
        action, 
        reason: transition.reason 
      })
      return
    }
    
    // Execute transition
    const newState = getNextState(currentState, action as DocumentAction)
    const timestamp = new Date().toISOString()
    
    // Update document
    const updatedDocument = {
      ...document,
      state: newState,
      updatedAt: timestamp,
      updatedBy: userId,
      history: [
        ...(document.history || []),
        {
          from: currentState,
          to: newState,
          action,
          userId,
          comment,
          timestamp,
          metadata
        }
      ]
    }
    
    await state.set('documents', documentId, updatedDocument)
    
    // Handle state-specific logic
    await handleStateTransition(newState, updatedDocument, { emit, state, logger })
    
    // Emit state change event
    await emit({
      topic: 'document.state.changed',
      data: {
        documentId,
        previousState: currentState,
        newState,
        action,
        userId,
        comment,
        timestamp
      }
    })
    
    logger.info('Document state transition completed', { 
      documentId, 
      transition: `${currentState} -> ${newState}`,
      action
    })
    
  } catch (error) {
    logger.error('Document state machine error', { 
      error: error.message, 
      documentId, 
      action 
    })
  }
}

function validateTransition(
  currentState: DocumentState, 
  action: DocumentAction, 
  userId: string, 
  document: any
): { valid: boolean; reason?: string } {
  // Define valid transitions
  const validTransitions: Record<DocumentState, DocumentAction[]> = {
    draft: ['submit'],
    submitted: ['approve', 'reject', 'withdraw'],
    under_review: ['approve', 'reject'],
    approved: ['publish', 'edit'],
    rejected: ['edit'],
    published: []
  }
  
  // Check if action is valid for current state
  if (!validTransitions[currentState].includes(action)) {
    return { valid: false, reason: 'Invalid action for current state' }
  }
  
  // Check permissions
  if (!hasPermission(userId, action, document)) {
    return { valid: false, reason: 'Insufficient permissions' }
  }
  
  return { valid: true }
}

function getNextState(currentState: DocumentState, action: DocumentAction): DocumentState {
  const transitions: Record<string, DocumentState> = {
    'draft:submit': 'submitted',
    'submitted:approve': 'approved',
    'submitted:reject': 'rejected',
    'submitted:withdraw': 'draft',
    'under_review:approve': 'approved',
    'under_review:reject': 'rejected',
    'approved:publish': 'published',
    'approved:edit': 'draft',
    'rejected:edit': 'draft'
  }
  
  return transitions[`${currentState}:${action}`] || currentState
}

async function handleStateTransition(
  newState: DocumentState, 
  document: any, 
  context: any
) {
  const { emit, state, logger } = context
  
  switch (newState) {
    case 'submitted':
      // Assign to reviewers
      await assignReviewers(document, context)
      break
      
    case 'approved':
      // Notify author
      await emit({
        topic: 'notification.send',
        data: {
          userId: document.authorId,
          type: 'success',
          title: 'Document Approved',
          message: `Your document "${document.title}" has been approved.`
        }
      })
      break
      
    case 'rejected':
      // Notify author with feedback
      await emit({
        topic: 'notification.send',
        data: {
          userId: document.authorId,
          type: 'warning',
          title: 'Document Rejected',
          message: `Your document "${document.title}" needs revision.`
        }
      })
      break
      
    case 'published':
      // Complete workflow
      await emit({
        topic: 'workflow.completed',
        data: {
          documentId: document.id,
          type: 'document_approval',
          result: 'published'
        }
      })
      break
  }
}

function hasPermission(userId: string, action: DocumentAction, document: any): boolean {
  // Implement permission checking logic
  const permissions = {
    submit: [document.authorId],
    approve: document.reviewers || [],
    reject: document.reviewers || [],
    publish: document.publishers || [],
    edit: [document.authorId],
    withdraw: [document.authorId]
  }
  
  return permissions[action]?.includes(userId) || false
}

async function assignReviewers(document: any, context: any) {
  // Logic to assign reviewers based on document type, department, etc.
  const reviewers = await getAvailableReviewers(document.category, context.state)
  
  // Update document with assigned reviewers
  document.reviewers = reviewers.map((r: any) => r.id)
  document.state = 'under_review'
  
  await context.state.set('documents', document.id, document)
  
  // Notify reviewers
  for (const reviewer of reviewers) {
    await context.emit({
      topic: 'notification.send',
      data: {
        userId: reviewer.id,
        type: 'info',
        title: 'Review Required',
        message: `Please review document: "${document.title}"`
      }
    })
  }
}
```

## Conditional Workflow Pattern

### Dynamic Route Selection

```typescript
// steps/workflows/loan-application/risk-assessor.step.ts
import { EventConfig, Handlers } from 'motia'
import { z } from 'zod'

export const config: EventConfig = {
  type: 'event',
  name: 'LoanRiskAssessor',
  description: 'Assess loan risk and route to appropriate approval process',
  subscribes: ['loan.application.submitted'],
  emits: ['loan.auto.approved', 'loan.manual.review', 'loan.rejected', 'loan.additional.docs.required'],
  input: z.object({
    applicationId: z.string(),
    applicantId: z.string(),
    loanAmount: z.number(),
    loanType: z.string(),
    applicantData: z.record(z.any()),
    creditScore: z.number().optional(),
    employmentHistory: z.array(z.record(z.any())).optional()
  }),
  flows: ['loan-processing']
}

export const handler: Handlers['LoanRiskAssessor'] = async (input, { emit, logger, state }) => {
  const { applicationId, applicantId, loanAmount, loanType, applicantData, creditScore } = input
  
  try {
    // Initialize workflow
    await state.set('workflows', `loan:${applicationId}`, {
      applicationId,
      status: 'risk_assessment',
      currentStep: 'risk_assessment',
      startedAt: new Date().toISOString()
    })
    
    // Perform risk assessment
    const riskAssessment = await assessLoanRisk(input)
    
    // Store assessment results
    await state.set('loan-assessments', applicationId, {
      ...riskAssessment,
      assessedAt: new Date().toISOString(),
      assessedBy: 'risk_engine'
    })
    
    // Route based on risk assessment
    const routingDecision = determineRouting(riskAssessment, loanAmount, loanType)
    
    // Update workflow with routing decision
    await updateWorkflowRoute(applicationId, routingDecision, state)
    
    // Emit appropriate event based on routing
    switch (routingDecision.route) {
      case 'auto_approve':
        await emit({
          topic: 'loan.auto.approved',
          data: {
            applicationId,
            applicantId,
            approvedAmount: routingDecision.approvedAmount,
            terms: routingDecision.terms,
            conditions: routingDecision.conditions
          }
        })
        break
        
      case 'manual_review':
        await emit({
          topic: 'loan.manual.review',
          data: {
            applicationId,
            applicantId,
            riskLevel: riskAssessment.riskLevel,
            reviewType: routingDecision.reviewType,
            priority: routingDecision.priority,
            assignTo: routingDecision.assignTo
          }
        })
        break
        
      case 'reject':
        await emit({
          topic: 'loan.rejected',
          data: {
            applicationId,
            applicantId,
            reason: routingDecision.reason,
            rejectionCode: routingDecision.rejectionCode
          }
        })
        break
        
      case 'request_docs':
        await emit({
          topic: 'loan.additional.docs.required',
          data: {
            applicationId,
            applicantId,
            requiredDocuments: routingDecision.requiredDocuments,
            deadline: routingDecision.deadline
          }
        })
        break
    }
    
    logger.info('Loan risk assessment completed', { 
      applicationId, 
      route: routingDecision.route,
      riskLevel: riskAssessment.riskLevel 
    })
    
  } catch (error) {
    logger.error('Loan risk assessment failed', { error: error.message, applicationId })
  }
}

async function assessLoanRisk(input: any) {
  const { loanAmount, applicantData, creditScore, employmentHistory } = input
  
  let riskScore = 0
  const factors = []
  
  // Credit score assessment
  if (creditScore) {
    if (creditScore >= 750) {
      riskScore += 10
      factors.push({ factor: 'credit_score', impact: 'positive', value: creditScore })
    } else if (creditScore >= 650) {
      riskScore += 5
      factors.push({ factor: 'credit_score', impact: 'neutral', value: creditScore })
    } else {
      riskScore -= 10
      factors.push({ factor: 'credit_score', impact: 'negative', value: creditScore })
    }
  }
  
  // Income assessment
  const monthlyIncome = applicantData.monthlyIncome || 0
  const debtToIncomeRatio = (loanAmount / 12) / monthlyIncome
  
  if (debtToIncomeRatio < 0.3) {
    riskScore += 5
    factors.push({ factor: 'debt_to_income', impact: 'positive', value: debtToIncomeRatio })
  } else if (debtToIncomeRatio > 0.5) {
    riskScore -= 15
    factors.push({ factor: 'debt_to_income', impact: 'negative', value: debtToIncomeRatio })
  }
  
  // Employment stability
  if (employmentHistory && employmentHistory.length > 0) {
    const currentEmployment = employmentHistory[0]
    const employmentMonths = currentEmployment.months || 0
    
    if (employmentMonths > 24) {
      riskScore += 5
      factors.push({ factor: 'employment_stability', impact: 'positive', value: employmentMonths })
    } else if (employmentMonths < 6) {
      riskScore -= 10
      factors.push({ factor: 'employment_stability', impact: 'negative', value: employmentMonths })
    }
  }
  
  // Determine overall risk level
  let riskLevel: 'low' | 'medium' | 'high'
  if (riskScore >= 15) {
    riskLevel = 'low'
  } else if (riskScore >= 0) {
    riskLevel = 'medium'
  } else {
    riskLevel = 'high'
  }
  
  return {
    riskScore,
    riskLevel,
    factors,
    recommendation: generateRecommendation(riskLevel, riskScore)
  }
}

function determineRouting(assessment: any, loanAmount: number, loanType: string) {
  const { riskLevel, riskScore } = assessment
  
  // Auto-approval criteria
  if (riskLevel === 'low' && loanAmount <= 50000 && loanType === 'personal') {
    return {
      route: 'auto_approve',
      approvedAmount: loanAmount,
      terms: { interestRate: 5.5, termMonths: 60 },
      conditions: ['standard_terms']
    }
  }
  
  // Rejection criteria
  if (riskLevel === 'high' && riskScore < -20) {
    return {
      route: 'reject',
      reason: 'High risk profile',
      rejectionCode: 'RISK_HIGH'
    }
  }
  
  // Document request criteria
  if (riskScore < 5 && loanAmount > 25000) {
    return {
      route: 'request_docs',
      requiredDocuments: ['proof_of_income', 'bank_statements', 'employment_verification'],
      deadline: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000).toISOString()
    }
  }
  
  // Default to manual review
  return {
    route: 'manual_review',
    reviewType: riskLevel === 'medium' ? 'standard' : 'detailed',
    priority: loanAmount > 100000 ? 'high' : 'normal',
    assignTo: 'loan_officers'
  }
}

function generateRecommendation(riskLevel: string, riskScore: number) {
  if (riskLevel === 'low') {
    return 'Recommend approval with standard terms'
  } else if (riskLevel === 'medium') {
    return 'Recommend manual review with potential approval'
  } else {
    return 'Recommend rejection or require additional documentation'
  }
}
```

This workflow pattern system provides:
- Linear sequential workflows with state tracking
- Parallel processing with fan-out/fan-in coordination
- State machine workflows for complex approval processes
- Conditional routing based on dynamic criteria
- Comprehensive error handling and recovery
- Workflow monitoring and progress tracking
- Flexible business rule evaluation
- Multi-step validation and verification processes