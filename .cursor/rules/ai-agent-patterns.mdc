---
description: AI Agent workflow patterns for building intelligent applications with Motia
globs: 
alwaysApply: false
---
# AI Agent Patterns

Build intelligent applications with AI agents using Motia's event-driven architecture for scalable, maintainable AI workflows.

## Core AI Agent Architecture

### AI Agent Configuration

```typescript
// steps/agents/core-agent.step.ts
import { EventConfig, Handlers } from 'motia'
import { z } from 'zod'

export const config: EventConfig = {
  type: 'event',
  name: 'CoreAIAgent',
  description: 'Main AI agent for processing user requests',
  subscribes: ['user.request', 'context.updated'],
  emits: ['agent.response', 'agent.thinking', 'agent.action.required'],
  input: z.object({
    userId: z.string(),
    message: z.string(),
    context: z.record(z.any()).optional(),
    sessionId: z.string(),
    metadata: z.object({
      timestamp: z.string(),
      source: z.string().optional(),
      priority: z.enum(['low', 'medium', 'high']).default('medium')
    })
  }),
  flows: ['ai-conversation']
}

export const handler: Handlers['CoreAIAgent'] = async (input, { emit, logger, state }) => {
  const { userId, message, context, sessionId } = input
  
  try {
    // Retrieve conversation history
    const conversationHistory = await state.get('conversations', sessionId) || []
    
    // Prepare context for AI
    const aiContext = {
      userMessage: message,
      history: conversationHistory.slice(-10), // Last 10 messages
      userProfile: await getUserProfile(userId, state),
      additionalContext: context || {}
    }
    
    // Emit thinking status for real-time feedback
    await emit({
      topic: 'agent.thinking',
      data: { sessionId, userId, status: 'processing' }
    })
    
    // Process with AI
    const aiResponse = await processWithAI(aiContext)
    
    // Update conversation history
    const updatedHistory = [
      ...conversationHistory,
      { role: 'user', content: message, timestamp: new Date().toISOString() },
      { role: 'assistant', content: aiResponse.content, timestamp: new Date().toISOString() }
    ]
    
    await state.set('conversations', sessionId, updatedHistory)
    
    // Emit response
    await emit({
      topic: 'agent.response',
      data: {
        sessionId,
        userId,
        response: aiResponse.content,
        confidence: aiResponse.confidence,
        suggestions: aiResponse.suggestions,
        needsAction: aiResponse.requiresAction
      }
    })
    
    // If action is required, emit action event
    if (aiResponse.requiresAction) {
      await emit({
        topic: 'agent.action.required',
        data: {
          sessionId,
          userId,
          action: aiResponse.suggestedAction,
          parameters: aiResponse.actionParameters
        }
      })
    }
    
    logger.info('AI agent processed user request', { userId, sessionId })
    
  } catch (error) {
    logger.error('AI agent processing failed', { error: error.message, userId, sessionId })
    
    await emit({
      topic: 'agent.response',
      data: {
        sessionId,
        userId,
        response: 'I apologize, but I encountered an error processing your request.',
        error: true
      }
    })
  }
}

async function processWithAI(context: any) {
  // AI processing logic (OpenAI, Claude, etc.)
  return {
    content: "AI generated response",
    confidence: 0.95,
    suggestions: ["Follow-up question 1", "Follow-up question 2"],
    requiresAction: false,
    suggestedAction: null,
    actionParameters: null
  }
}

async function getUserProfile(userId: string, state: any) {
  return await state.get('users', `profile:${userId}`) || {}
}
```

## Multi-Step AI Workflows

### Planning Agent

```typescript
// steps/agents/planner-agent.step.ts
import { EventConfig, Handlers } from 'motia'
import { z } from 'zod'

export const config: EventConfig = {
  type: 'event',
  name: 'PlannerAgent',
  description: 'Breaks down complex tasks into actionable steps',
  subscribes: ['task.complex', 'plan.revision.requested'],
  emits: ['plan.created', 'step.ready', 'executor.start'],
  input: z.object({
    taskDescription: z.string(),
    goals: z.array(z.string()),
    constraints: z.record(z.any()).optional(),
    userId: z.string(),
    priority: z.enum(['low', 'medium', 'high']).default('medium')
  }),
  flows: ['ai-task-execution']
}

export const handler: Handlers['PlannerAgent'] = async (input, { emit, logger, state }) => {
  const { taskDescription, goals, constraints, userId } = input
  
  try {
    // Generate execution plan using AI
    const plan = await generateExecutionPlan({
      task: taskDescription,
      goals,
      constraints: constraints || {},
      userContext: await state.get('users', `context:${userId}`)
    })
    
    // Store the plan
    const planId = crypto.randomUUID()
    await state.set('plans', planId, {
      ...plan,
      userId,
      status: 'created',
      createdAt: new Date().toISOString()
    })
    
    // Emit plan created event
    await emit({
      topic: 'plan.created',
      data: { planId, userId, plan, totalSteps: plan.steps.length }
    })
    
    // Emit individual steps for execution
    for (const [index, step] of plan.steps.entries()) {
      await emit({
        topic: 'step.ready',
        data: {
          planId,
          stepId: step.id,
          stepIndex: index,
          description: step.description,
          type: step.type,
          parameters: step.parameters,
          dependencies: step.dependencies
        }
      })
    }
    
    // Start execution
    await emit({
      topic: 'executor.start',
      data: { planId, userId, firstStepId: plan.steps[0].id }
    })
    
    logger.info('Execution plan created', { planId, userId, stepCount: plan.steps.length })
    
  } catch (error) {
    logger.error('Plan creation failed', { error: error.message, userId })
  }
}

async function generateExecutionPlan(context: any) {
  // AI-powered planning logic
  return {
    id: crypto.randomUUID(),
    title: context.task,
    steps: [
      {
        id: crypto.randomUUID(),
        description: "Research and gather information",
        type: "research",
        parameters: { query: context.task },
        dependencies: [],
        estimatedTime: 300
      },
      {
        id: crypto.randomUUID(),
        description: "Analyze findings and create draft",
        type: "analysis",
        parameters: { method: "structured_analysis" },
        dependencies: [],
        estimatedTime: 600
      }
    ],
    estimatedTotalTime: 900
  }
}
```

### Executor Agent

```typescript
// steps/agents/executor-agent.step.ts
import { EventConfig, Handlers } from 'motia'
import { z } from 'zod'

export const config: EventConfig = {
  type: 'event',
  name: 'ExecutorAgent',
  description: 'Executes individual steps from execution plans',
  subscribes: ['step.ready', 'step.retry'],
  emits: ['step.completed', 'step.failed', 'plan.progress', 'next.step'],
  input: z.object({
    planId: z.string(),
    stepId: z.string(),
    stepIndex: z.number(),
    description: z.string(),
    type: z.string(),
    parameters: z.record(z.any()),
    dependencies: z.array(z.string())
  }),
  flows: ['ai-task-execution']
}

export const handler: Handlers['ExecutorAgent'] = async (input, { emit, logger, state }) => {
  const { planId, stepId, stepIndex, description, type, parameters } = input
  
  try {
    // Check dependencies
    const dependenciesMet = await checkDependencies(input.dependencies, planId, state)
    if (!dependenciesMet) {
      logger.warn('Step dependencies not met, waiting', { stepId, planId })
      return
    }
    
    // Execute step based on type
    const result = await executeStep(type, parameters, { state, logger })
    
    // Store result
    await state.set('step-results', `${planId}:${stepId}`, {
      ...result,
      stepId,
      planId,
      completedAt: new Date().toISOString()
    })
    
    // Emit completion
    await emit({
      topic: 'step.completed',
      data: {
        planId,
        stepId,
        stepIndex,
        result,
        nextStepReady: result.nextStepReady || false
      }
    })
    
    // Update plan progress
    await emit({
      topic: 'plan.progress',
      data: {
        planId,
        completedSteps: stepIndex + 1,
        currentStep: result.nextStepReady ? stepIndex + 1 : null
      }
    })
    
    // Trigger next step if ready
    if (result.nextStepReady) {
      await emit({
        topic: 'next.step',
        data: { planId, nextStepIndex: stepIndex + 1 }
      })
    }
    
    logger.info('Step executed successfully', { stepId, planId, type })
    
  } catch (error) {
    logger.error('Step execution failed', { error: error.message, stepId, planId })
    
    await emit({
      topic: 'step.failed',
      data: {
        planId,
        stepId,
        stepIndex,
        error: error.message,
        retryable: isRetryableError(error)
      }
    })
  }
}

async function executeStep(type: string, parameters: any, context: any) {
  switch (type) {
    case 'research':
      return await executeResearchStep(parameters, context)
    case 'analysis':
      return await executeAnalysisStep(parameters, context)
    case 'generation':
      return await executeGenerationStep(parameters, context)
    default:
      throw new Error(`Unknown step type: ${type}`)
  }
}

async function executeResearchStep(params: any, ctx: any) {
  // Research implementation
  return {
    data: { findings: ["Finding 1", "Finding 2"] },
    nextStepReady: true,
    confidence: 0.9
  }
}

async function checkDependencies(deps: string[], planId: string, state: any) {
  for (const dep of deps) {
    const result = await state.get('step-results', `${planId}:${dep}`)
    if (!result) return false
  }
  return true
}

function isRetryableError(error: any) {
  // Determine if error is retryable
  return !error.message.includes('invalid_parameters')
}
```

## Specialized AI Agents

### Content Generation Agent

```typescript
// steps/agents/content-generator.step.ts
import { EventConfig, Handlers } from 'motia'
import { z } from 'zod'

export const config: EventConfig = {
  type: 'event',
  name: 'ContentGenerator',
  description: 'Generates various types of content using AI',
  subscribes: ['content.generation.requested'],
  emits: ['content.generated', 'content.draft.ready'],
  input: z.object({
    contentType: z.enum(['article', 'email', 'summary', 'code', 'presentation']),
    prompt: z.string(),
    style: z.string().optional(),
    length: z.enum(['short', 'medium', 'long']).default('medium'),
    audience: z.string().optional(),
    userId: z.string(),
    metadata: z.record(z.any()).optional()
  }),
  flows: ['content-creation']
}

export const handler: Handlers['ContentGenerator'] = async (input, { emit, logger, state }) => {
  const { contentType, prompt, style, length, audience, userId } = input
  
  try {
    // Prepare generation context
    const context = {
      type: contentType,
      prompt,
      style: style || await getUserPreferredStyle(userId, state),
      length,
      audience: audience || 'general',
      userProfile: await state.get('users', `profile:${userId}`)
    }
    
    // Generate content
    const generatedContent = await generateContent(context)
    
    // Store content
    const contentId = crypto.randomUUID()
    await state.set('content', contentId, {
      ...generatedContent,
      userId,
      type: contentType,
      status: 'draft',
      createdAt: new Date().toISOString()
    })
    
    // Emit events
    await emit({
      topic: 'content.generated',
      data: {
        contentId,
        userId,
        content: generatedContent.text,
        metadata: generatedContent.metadata,
        type: contentType
      }
    })
    
    await emit({
      topic: 'content.draft.ready',
      data: {
        contentId,
        userId,
        title: generatedContent.title,
        preview: generatedContent.text.substring(0, 200) + '...'
      }
    })
    
    logger.info('Content generated successfully', { contentId, userId, type: contentType })
    
  } catch (error) {
    logger.error('Content generation failed', { error: error.message, userId, contentType })
  }
}

async function generateContent(context: any) {
  // AI content generation logic
  return {
    title: "Generated Title",
    text: "Generated content based on the prompt...",
    metadata: {
      wordCount: 250,
      readingTime: "2 minutes",
      keywords: ["keyword1", "keyword2"]
    },
    suggestions: ["Suggestion 1", "Suggestion 2"]
  }
}

async function getUserPreferredStyle(userId: string, state: any) {
  const profile = await state.get('users', `profile:${userId}`)
  return profile?.preferredStyle || 'professional'
}
```

### Decision Making Agent

```typescript
// steps/agents/decision-maker.step.ts
import { EventConfig, Handlers } from 'motia'
import { z } from 'zod'

export const config: EventConfig = {
  type: 'event',
  name: 'DecisionMaker',
  description: 'Makes intelligent decisions based on data and rules',
  subscribes: ['decision.required', 'data.analysis.complete'],
  emits: ['decision.made', 'recommendation.created', 'escalation.required'],
  input: z.object({
    decisionType: z.string(),
    context: z.record(z.any()),
    criteria: z.array(z.object({
      name: z.string(),
      weight: z.number(),
      threshold: z.number().optional()
    })),
    options: z.array(z.record(z.any())),
    userId: z.string().optional(),
    autoExecute: z.boolean().default(false)
  }),
  flows: ['decision-making']
}

export const handler: Handlers['DecisionMaker'] = async (input, { emit, logger, state }) => {
  const { decisionType, context, criteria, options, userId, autoExecute } = input
  
  try {
    // Analyze options against criteria
    const analysis = await analyzeOptions(options, criteria, context)
    
    // Make decision
    const decision = await makeDecision(analysis, criteria, context)
    
    // Store decision
    const decisionId = crypto.randomUUID()
    await state.set('decisions', decisionId, {
      id: decisionId,
      type: decisionType,
      decision: decision.choice,
      confidence: decision.confidence,
      reasoning: decision.reasoning,
      alternatives: decision.alternatives,
      userId,
      createdAt: new Date().toISOString(),
      executed: false
    })
    
    // Emit appropriate event based on confidence
    if (decision.confidence > 0.8 && autoExecute) {
      await emit({
        topic: 'decision.made',
        data: {
          decisionId,
          decision: decision.choice,
          confidence: decision.confidence,
          autoExecuted: true,
          reasoning: decision.reasoning
        }
      })
    } else if (decision.confidence > 0.6) {
      await emit({
        topic: 'recommendation.created',
        data: {
          decisionId,
          recommendation: decision.choice,
          confidence: decision.confidence,
          alternatives: decision.alternatives,
          requiresApproval: true
        }
      })
    } else {
      await emit({
        topic: 'escalation.required',
        data: {
          decisionId,
          reason: 'Low confidence decision',
          confidence: decision.confidence,
          options: options,
          humanReviewRequired: true
        }
      })
    }
    
    logger.info('Decision processing completed', { 
      decisionId, 
      type: decisionType, 
      confidence: decision.confidence 
    })
    
  } catch (error) {
    logger.error('Decision making failed', { error: error.message, decisionType })
  }
}

async function analyzeOptions(options: any[], criteria: any[], context: any) {
  // AI-powered option analysis
  return options.map(option => ({
    option,
    scores: criteria.map(criterion => ({
      criterion: criterion.name,
      score: Math.random(), // Replace with actual scoring logic
      reasoning: `Analysis for ${criterion.name}`
    })),
    totalScore: Math.random()
  }))
}

async function makeDecision(analysis: any[], criteria: any[], context: any) {
  // Decision logic
  const bestOption = analysis.reduce((best, current) => 
    current.totalScore > best.totalScore ? current : best
  )
  
  return {
    choice: bestOption.option,
    confidence: bestOption.totalScore,
    reasoning: `Selected based on highest score: ${bestOption.totalScore}`,
    alternatives: analysis.filter(a => a !== bestOption).slice(0, 2)
  }
}
```

## AI Agent Coordination

### Agent Orchestrator

```typescript
// steps/agents/orchestrator.step.ts
import { EventConfig, Handlers } from 'motia'
import { z } from 'zod'

export const config: EventConfig = {
  type: 'event',
  name: 'AgentOrchestrator',
  description: 'Coordinates multiple AI agents for complex workflows',
  subscribes: ['workflow.complex.started', 'agent.completed', 'agent.failed'],
  emits: ['agent.assigned', 'workflow.progress', 'workflow.completed'],
  input: z.union([
    z.object({
      type: z.literal('start'),
      workflowId: z.string(),
      task: z.string(),
      requiredCapabilities: z.array(z.string()),
      userId: z.string()
    }),
    z.object({
      type: z.literal('agent_result'),
      workflowId: z.string(),
      agentId: z.string(),
      result: z.record(z.any()),
      status: z.enum(['completed', 'failed'])
    })
  ]),
  flows: ['agent-coordination']
}

export const handler: Handlers['AgentOrchestrator'] = async (input, { emit, logger, state }) => {
  if (input.type === 'start') {
    await handleWorkflowStart(input, { emit, logger, state })
  } else {
    await handleAgentResult(input, { emit, logger, state })
  }
}

async function handleWorkflowStart(input: any, ctx: any) {
  const { workflowId, task, requiredCapabilities, userId } = input
  
  // Find available agents for required capabilities
  const availableAgents = await findAgentsForCapabilities(requiredCapabilities, ctx.state)
  
  // Create workflow plan
  const workflowPlan = await createAgentWorkflowPlan(task, availableAgents)
  
  // Store workflow state
  await ctx.state.set('workflows', workflowId, {
    id: workflowId,
    userId,
    task,
    plan: workflowPlan,
    status: 'in_progress',
    assignedAgents: workflowPlan.agents,
    createdAt: new Date().toISOString()
  })
  
  // Assign first set of agents
  for (const assignment of workflowPlan.initialAssignments) {
    await ctx.emit({
      topic: 'agent.assigned',
      data: {
        workflowId,
        agentId: assignment.agentId,
        task: assignment.task,
        parameters: assignment.parameters
      }
    })
  }
  
  ctx.logger.info('Workflow started with agent assignments', { 
    workflowId, 
    agentCount: workflowPlan.agents.length 
  })
}

async function findAgentsForCapabilities(capabilities: string[], state: any) {
  // Find available agents matching required capabilities
  const allAgents = await state.get('agents', 'available') || []
  return allAgents.filter((agent: any) => 
    capabilities.every(cap => agent.capabilities.includes(cap))
  )
}

async function createAgentWorkflowPlan(task: string, agents: any[]) {
  // Create a plan for coordinating multiple agents
  return {
    agents: agents.map(a => a.id),
    phases: [
      {
        name: 'analysis',
        agents: [agents[0]?.id],
        dependencies: []
      },
      {
        name: 'execution',
        agents: agents.slice(1).map(a => a.id),
        dependencies: ['analysis']
      }
    ],
    initialAssignments: [
      {
        agentId: agents[0]?.id,
        task: 'Analyze the task requirements',
        parameters: { task }
      }
    ]
  }
}
```

This AI agent pattern system provides:
- Modular AI agents for different capabilities
- Event-driven coordination between agents
- Multi-step AI workflows with planning and execution
- Specialized agents for content generation, decision making
- Orchestration system for complex multi-agent workflows
- Error handling and retry mechanisms
- State management for conversation history and workflow progress