---
description: State management between steps
globs: 
alwaysApply: false
---
# Motia State Management

State management in Motia allows data to be persisted and shared between steps within a single workflow execution (flow instance), identified by a unique `traceId`.

## Core Concepts

-   **Zero-config in-memory storage**: Default adapter, easy to get started.
-   **Flexible storage adapters**: Supports Memory (default), File system, and Redis for more persistent or distributed state.
-   **Automatic state cleanup with TTL**: Configurable Time-To-Live for state entries, especially useful with adapters like Redis.
-   **Flow-level isolation using `traceId`**: Each flow execution has its own isolated state, preventing data collision between different workflow runs. The `traceId` acts as the primary scope or namespace for all state operations within that flow instance.

## Basic Usage

The `state` object is available in the handler's context.

**TypeScript Example:**
```typescript
// Assuming FlowContext is imported or defined, providing 'state' and 'traceId'.
// import { FlowContext } from 'motia';

// Example handler function demonstrating state operations.
export const handler = async (input: any, { state, traceId, logger }: FlowContext) => {
  // 'traceId' is crucial: it scopes all state operations to the current flow instance.
  
  // Store data: Associates 'resourceObject' with the key 'resource' under the current 'traceId'.
  // The value can be any JSON-serializable object.
  const resourceObject = { 
    id: 'res_001', 
    title: 'Sample Resource', 
    category: 'documents', 
    metadata: { tags: ['important', 'draft'], priority: 'high' } 
  };
  await state.set(traceId, 'resource', resourceObject);
  logger.info('Resource data stored in state', { traceId, key: 'resource', value: resourceObject });

  // Retrieve data: Fetches the value associated with the key 'resource' for the current 'traceId'.
  // It's good practice to type the expected return value if known.
  const retrievedResource = await state.get<{ 
    id: string, 
    title: string, 
    category: string, 
    metadata: { tags: string[], priority: string } 
  }>(traceId, 'resource');
  if (retrievedResource) {
    logger.info('Resource data retrieved from state', { traceId, key: 'resource', value: retrievedResource });
    // console.log(retrievedResource.title); // Sample Resource
  } else {
    logger.warn('No resource data found in state for key', { traceId, key: 'resource' });
  }
  
  // Delete specific data: Removes the key-value pair for 'resource' under the current 'traceId'.
  await state.delete(traceId, 'resource');
  logger.info('Resource data deleted from state', { traceId, key: 'resource' });

  // Clear all flow state: Removes all key-value pairs associated with the current 'traceId'.
  // Use with caution, as this erases all state for the flow instance.
  await state.clear(traceId);
  logger.info('All state cleared for flow instance', { traceId });
};
```

**Python Example:**
```python
# 'ctx' (context object) provides access to 'state' and 'trace_id'.
async def handler(input_data, ctx):
    # 'trace_id' scopes state operations to the current flow instance.
    trace_id = ctx.trace_id
 
    # Store state: Associates 'task_details' with the key 'task' under 'trace_id'.
    # 'input_data' might contain task information and configuration.
    task_details = {
        'task_id': getattr(input_data, 'id', 'unknown_id'),
        'type': getattr(input_data, 'type', 'generic'),
        'priority': getattr(input_data, 'priority', 'medium'),
        'status': 'processing',
        'created_at': ctx.utils.dates.now().isoformat(),
        'progress': {
            'current_step': 1,
            'total_steps': 3,
            'completion_rate': 0.33
        }
    }
    await ctx.state.set(trace_id, 'task', task_details)
    ctx.logger.info(f"Task details stored for traceId: {trace_id}")
 
    # Retrieve state: Fetches the 'task' data for 'trace_id'.
    retrieved_task = await ctx.state.get(trace_id, 'task')
    if retrieved_task:
        ctx.logger.info(f"Retrieved task: {retrieved_task} for traceId: {trace_id}")
    else:
        ctx.logger.warn(f"No task found for traceId: {trace_id}, key: task")
 
    # Delete specific state: Removes the 'task' data for 'trace_id'.
    await ctx.state.delete(trace_id, 'task')
    ctx.logger.info(f"Task details deleted for traceId: {trace_id}")
 
    # Clear all state for this flow instance: Removes all keys under 'trace_id'.
    await ctx.state.clear(trace_id)
    ctx.logger.info(f"All state cleared for trace_id: {trace_id}")
```

**Ruby Example:**
```ruby
# 'context' object provides access to 'state' and 'trace_id'.
def handler(input_data, context)
  # 'trace_id' scopes state operations to the current flow instance.
  trace_id = context.trace_id
 
  # Store state: Associates 'operation_details' with the key 'operation' under 'trace_id'.
  # 'input_data' might be a hash or an object with operation attributes.
  operation_details = {
    operation_id: input_data[:id] || 'unknown_operation',
    name: input_data[:name] || 'Generic Operation',
    category: input_data[:category] || 'processing',
    status: 'in_progress',
    started_at: Time.now.utc.iso8601,
    configuration: {
      retries: 3,
      timeout: 30,
      priority: input_data[:priority] || 'medium'
    },
    metrics: {
      attempts: 1,
      success_rate: 1.0
    }
  }
  context.state.set(trace_id, 'operation', operation_details)
  context.logger.info("Operation details stored for trace_id: #{trace_id}")
 
  # Retrieve state: Fetches the 'operation' data for 'trace_id'.
  retrieved_operation = context.state.get(trace_id, 'operation')
  if retrieved_operation
    context.logger.info("Retrieved operation: #{retrieved_operation.inspect} for trace_id: #{trace_id}")
  else
    context.logger.warn("No operation found for trace_id: #{trace_id}, key: operation")
  end
 
  # Delete specific state: Removes the 'operation' data for 'trace_id'.
  context.state.delete(trace_id, 'operation')
  context.logger.info("Operation details deleted for trace_id: #{trace_id}")
 
  # Clear all state for this flow instance: Removes all keys under 'trace_id'.
  context.state.clear(trace_id)
  context.logger.info("All state cleared for trace_id: #{trace_id}")
end
```

## State Methods

| Method   | Usage                                       | Description                                                                 |
| :------- | :------------------------------------------ | :-------------------------------------------------------------------------- |
| `get`    | `await state.get(traceId, key)`             | Retrieves the value associated with `key` for the given `traceId`.          |
| `set`    | `await state.set(traceId, key, value)`      | Stores the `value` associated with `key` for the given `traceId`.           |
| `delete` | `await state.delete(traceId, key)`          | Deletes the key-value pair for `key` for the given `traceId`.             |
| `clear`  | `await state.clear(traceId)`                | Removes all key-value pairs associated with the given `traceId`.            |

## Storage Adapters

Configure storage adapters in `config.yml` (or `config.yaml`) in your project root.

```
my-motia-project/
├── config.yml       # Motia configuration file
└── steps/
    ├── step-1.ts
    └── step-2.ts
```

### Memory (Default)
No explicit configuration needed, but can be specified. Ideal for development and simple use cases. State is lost when the process restarts.
```yaml
# config.yml
state:
  adapter: memory # This is the default if 'state' section is omitted or 'adapter' is not specified.
```

### File
Persists state to a local JSON file. Useful for simple persistence across restarts without external services.
```yaml
# config.yml
state:
  adapter: file
  # 'path' specifies the location of the state file.
  # It's recommended to place it in a non-source controlled directory like '.motia/'.
  path: '.motia/state.json'
```

### Redis
Uses a Redis server for state storage. Suitable for production, distributed environments, and when using features like TTL.
```yaml
# config.yml
state:
  adapter: redis
  host: localhost      # Redis server hostname (default: 'localhost')
  port: 6379           # Redis server port (default: 6379)
  password: yourpassword # Optional: Password for Redis authentication (if configured).
  db: 0                # Optional: Redis database number (default: 0).
  ttl: 3600            # Optional: Default Time-To-Live for state entries in seconds (e.g., 3600 for 1 hour).
                       # If not set, keys persist indefinitely unless explicitly deleted or Redis eviction policies apply.
```

## Best Practices

### 1. Type Safety (TypeScript & Python)
Define types or data classes for your state objects to improve code clarity, maintainability, and catch errors early.

**TypeScript:**
```typescript
// Define interfaces for structured state data.
interface ResourceData {
  id: string;
  title: string;
  category: string;
  tags: string[];
}
 
interface ProcessingConfig {
  retries: number;
  timeout: number;
  priority: 'low' | 'medium' | 'high';
}
 
// Define a type for the overall processing state.
type ProcessingState = {
  resourceDetails: ResourceData;
  configuration: ProcessingConfig;
  status: 'queued' | 'processing' | 'completed' | 'failed';
  progress: {
    currentStep: number;
    totalSteps: number;
    percentage: number;
  };
  lastUpdated: string;
};
 
// When retrieving state, use the generic type parameter to specify the expected shape.
// This provides type checking and autocompletion.
// const processingJob = await state.get<ProcessingState>(traceId, 'currentProcessing');
// if (processingJob) {
//   console.log(processingJob.resourceDetails.title);
//   console.log(processingJob.status);
//   console.log(processingJob.progress.percentage);
// }
```

**Python (using dataclasses):**
```python
from dataclasses import dataclass
from typing import Literal, List # For defining specific string literals as types

# Define data classes for structured state data.
@dataclass
class ResourceData:
    id: str
    title: str
    category: str
    tags: List[str]
 
@dataclass
class ProcessingConfig:
    retries: int
    timeout: int
    priority: Literal['low', 'medium', 'high']
 
@dataclass
class ProcessingProgress:
    current_step: int
    total_steps: int
    percentage: float
 
# Define a data class for the overall processing state.
@dataclass
class ProcessingState:
    resource_details: ResourceData
    configuration: ProcessingConfig
    status: Literal['queued', 'processing', 'completed', 'failed'] # Ensures status is one of these values.
    progress: ProcessingProgress
    last_updated: str

# While Python's state.get doesn't have generic type hints like TypeScript's,
# you can cast or validate the retrieved data against your dataclass.
# raw_processing_data = await ctx.state.get(trace_id, 'current_processing')
# if raw_processing_data:
#     # You might perform validation here or directly instantiate your dataclass
#     # For example (assuming raw_processing_data is a dict):
#     # resource = ResourceData(**raw_processing_data['resource_details'])
#     # config = ProcessingConfig(**raw_processing_data['configuration'])
#     # progress = ProcessingProgress(**raw_processing_data['progress'])
#     # processing = ProcessingState(resource, config, raw_processing_data['status'], progress, raw_processing_data['last_updated'])
#     pass # Process the retrieved data
```

### 2. Hierarchical Keys
Use dot-notation or a consistent naming convention for keys to create a logical hierarchy, making state easier to manage and understand.

**TypeScript Example:**
```typescript
// Good: Using a structured approach for keys.
// await state.set(traceId, 'processing.resource', resourceData);
// await state.set(traceId, 'processing.config', configurationData);
// await state.set(traceId, 'processing.status', 'queued');
// await state.set(traceId, 'processing.progress', progressData);

// const resource = await state.get<ResourceData>(traceId, 'processing.resource');
// const status = await state.get<string>(traceId, 'processing.status');

// Avoid: Flat, potentially ambiguous keys if the workflow grows.
// await state.set(traceId, 'resourceDataForProcessing', resourceData);
// await state.set(traceId, 'configurationDataForProcessing', configurationData);
```

### 3. Cleanup
Explicitly clear state when it's no longer needed, especially for large data or sensitive information, to free up resources and avoid unintended data persistence. This is crucial for long-running flows or when using persistent adapters like Redis without aggressive TTLs.

**TypeScript Example (using `finally` for guaranteed cleanup):**
```typescript
// async function processData() { /* ... your logic ... */ }

// try {
//   // Perform operations that might use state.
//   // await processData(input, { state, traceId, logger });
//   await state.set(traceId, 'intermediateResult', { value: 123 });
// } catch (error) {
//   // Handle errors appropriately.
//   logger.error('Error during processing, state might be inconsistent.', { traceId, error });
// } finally {
//   // Ensure state cleanup happens whether the try block succeeds or fails.
//   // Decide whether to clear specific keys or the entire flow's state.
//   await state.delete(traceId, 'intermediateResult');
//   // Or, if all state for this flow instance is done:
//   // await state.clear(traceId);
//   logger.info('State cleanup performed for flow instance', { traceId });
// }
```

**Python Example (using `try...finally`):**
```python
# async def process_booking(input_data, ctx): # ... your logic ...

async def handler_with_cleanup(input_data, ctx):
    trace_id = ctx.trace_id
    try:
        # Perform operations that use state.
        # await process_booking(input_data, ctx)
        await ctx.state.set(trace_id, 'payment.status', 'processing')
        # ... other operations ...
        await ctx.state.set(trace_id, 'payment.status', 'completed')

    except Exception as e:
        ctx.logger.error(f"Error during booking process for {trace_id}: {e}")
        # Optionally set an error state
        await ctx.state.set(trace_id, 'flow.error', str(e))
    finally:
        # Cleanup: Decide what to clear.
        # For instance, clear temporary payment status but keep final booking details.
        await ctx.state.delete(trace_id, 'payment.status')
        ctx.logger.info(f"Payment status state cleared for trace_id: {trace_id}")
        
        # If the entire flow's state should be purged (e.g., on completion or unrecoverable error):
        # await ctx.state.clear(trace_id)
        # ctx.logger.info(f"All state cleared for trace_id: {trace_id}")
```

## Additional Docs
For more comprehensive information, refer to the official documentation:
State Management: `https://motia.dev/docs/concepts/state-management` 